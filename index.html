<!doctype html><html><head><style type="text/css">#gameBoard {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
    image-rendering: crisp-edges;
}</style></head><body>

	<!DOCTYPE html>
	<html>

	<body>
		<canvas id='gameBoard'>
		</canvas>

		<script type="text/javascript">
			"use strict";

const loadingScreenVertexShader = `#version 300 es
precision mediump float;
in vec2 vertex;
out vec2 f_vertex;
void main(){
  gl_Position = vec4(vertex, 0.0, 1.0);
  f_vertex = vertex;
}
`
const loadingScreenFragmentShader = `#version 300 es
precision mediump float;
in vec2 f_vertex;
uniform float percentage;
uniform vec2 viewport;
uniform sampler2D tex;
out vec4 outColor;

void main(){
  vec2 coord = gl_FragCoord.xy / viewport.xy;
  coord = coord * 2.0 - 1.0;
  float percent_space = percentage * 1.5 - 0.75;
 
if((coord.x>-0.75) && (coord.y>-0.75) && (coord.x<0.75) && (coord.y<-0.6)){
outColor = vec4(0.0, 1.0, 1.0, 1.0);
 if(coord.x<percent_space && coord.y<0.0 - 0.6 && coord.y> -0.75 && coord.x>-0.75){
outColor = vec4(1.0, 0.0, 1.0, 1.0);
}
}else{
  vec2 texcoords = (coord + 1.0) / 2.0;
  outColor = texture(tex, vec2(texcoords.x, 0.0-texcoords.y));
}


}
`

const vertexShader = `#version 300 es
precision mediump float;
in vec3 a_Position;
in vec2 a_texCoord;
uniform mat4 world;
uniform mat4 view;
uniform mat4 projection;
out vec2 f_tex_coord;
void main(){
  f_tex_coord = a_texCoord;
  gl_Position = projection * view * world * vec4(a_Position, 1.0);
}

`;
const fragmentShader = `#version 300 es
precision mediump float;
in vec2 f_tex_coord;
uniform sampler2D color_tex;
out vec4 outColor;
void main(){
  
outColor = vec4(texture(color_tex, f_tex_coord).xyz, 1.0);

}
`;
const textVertexShader = `# version 300 es
precision mediump float;
in vec2 position;
in vec2 texCoord;
in uniform position_offset;
out vec2 f_tex_coord;
void main(){
f_tex_coord = texCoord;
gl_Position = vec4(position + position_offset, 0.0, 1.0);
}
`;
const textFragmentShader = `#version 300 es
precision mediump float;
in vec2 f_tex_coord;
uniform sampler2D texture_atalas;
out vec4 out_color;
void main(){
float color = texture(texture_atlas, f_tex_coord).xyz;
if(color.x = 0.0 || color.y = 0.0 || color.z = 0.0){
  discard;
}
out_color = vec4(color, 1.0);
}


`
async function toText(url, stream){
const responseStream = new Response(stream);
const text = await responseStream.blob().text();
const json = JSON.parse(text);
assets = json.assets;
assetList = json.assetList;
}
async function downloadAssets(url){
try {
// fetch the file"http://www.geom.uiuc.edu/~huberty/math5337/groupe/digits.html");
let response = await fetch(url);
// check if the response is ok

if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

// get the total size of the file
const contentLength = response.headers.get('content-length');

// set the max value of the progress bar
const totalSize = contentLength ? parseInt(contentLength, 10) : 0;

// create the stream
const reader = response.body.getReader();

const stream = new ReadableStream({
// start the stream
async start(controller) {
let loaded = 0;
while (true) {
// read the next chuck of data
const { done, value } = await reader.read();
// simulate network delay
await delay(100);

if (done) break;

// calcualte the progress %
loaded += value.length;
const progress = totalSize ? (loaded / totalSize) * 100 : 0;

// update the progressbar
percentage = progress * 0.5


// send the data to the controller
controller.enqueue(value);
}
// close the stream
controller.close();
},
});

// create the download link
toText(url, stream);

// Update the progress text
progressText.textContent = 'Download Complete!';
} catch (error) {
// update the progress text
progressText.textContent = 'Download Failed!' + error;
} finally {
// enable the download button
downloadBtn.disabled = false;
}



};


var cameraRotation = [0.0, 0.0, 0.0]
var texts = [];
var mouseX = 0;
var mouseY = 0;
var isDone = false;
var percentage = 0.0;
var files = [];
var assets = [{data: [
  // Front face
  -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,

  // Back face
  -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0,

  // Top face
  -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,

  // Bottom face
  -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,

  // Right face
  1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,

  // Left face
  -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
], usage:35044}, {data:[
     0,  1,  2,      0,  2,  3,    // front
     4,  5,  6,      4,  6,  7,    // back
     8,  9,  10,     8,  10, 11,   // top
     12, 13, 14,     12, 14, 15,   // bottom
     16, 17, 18,     16, 18, 19,   // right
     20, 21, 22,     20, 22, 23,   // left
  ]
, usage:35044}, {data:vertexShader, usage:null}, {data:[1.0,1.0, 1.0, 1.0,1.0,1.0, 1.0, 1.0, // Front face: white
  1.0, 0.5, 1.0, 0.5,1.0, 0.5,1.0, 0.5, // Back face: red
1.0, 0.0, 1.0, 0.0,1.0, 0.0, 1.0, 0.0, // Top face: green
  0.5, 1.0,0.5, 1.0,0.5, 1.0,0.5, 1.0, // Bottom face: blue
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, // Right face: yellow
  0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0], usage:35044/*gl.STATIC_DRAW*/}, {data:fragmentShader, usage:null},{data:`data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAM0lEQVR4AQAnANj/Av8AAP8r/wD/ACT//wIAAP0A1PMAAACoAAACASQCAAEy/wAAWAAAAAAA//8XQrlKAAAABklEQVQDABmLC22m5EM0AAAAAElFTkSuQmCC`,
usage:null}, {data:[], usage:35044}];

var assetList = [{fileType:"text",type:"vertexBuffer", data:0, usage:35044/*gl.STATIC_DRAW*/, arrayType:Float32Array}, {fileType:"text",type:"indexBuffer", data:1, usage:35044/*gl.STATIC_DRAW*/, arrayType:Uint16Array}, {fileType:"text",type:"vertexShader", data:2, usage:null}, {fileType:"text",type:"vertexBuffer", data:3, usage:35044, arrayType:Float32Array},{fileType:"text",type:"fragmentShader", data:4, usage:null},{fileType:"image", type:"texture", data:5, usage:null, url:`data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAM0lEQVR4AQAnANj/Av8AAP8r/wD/ACT//wIAAP0A1PMAAACoAAACASQCAAEy/wAAWAAAAAAA//8XQrlKAAAABklEQVQDABmLC22m5EM0AAAAAElFTkSuQmCC`}, {fileType:"text",type:"vertexBuffer", data:6, usage:35044, arrayType:Float32Array}];

var loadingScreen = {
  attribName: ["vertex"], vertexShader: loadingScreenVertexShader, vertexSize: 2, fragmentShader:
    loadingScreenFragmentShader, vertexData: [-1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], indexData: [0, 2, 1, 0, 3, 2],
  vertexNormal: false, vertexStride: 0, vertexOffset: 0, uniformNames: [`percentage`, "viewport", "tex"], numUniformLocations: 3
};
const vaos = [{
  attribs: [{num:3, size:2, type:5126, normalized:false, stride:8, offset:0}, {num:0, size:3, type:5126, normalized:false, stride:12, offset:0}], indexBuffer: 1, shaderProgram: 0
}

];

var vaoIds = [];
var shaderPrograms = [{vertexShader: 2, fragmentShader: 4, attributes:["a_texCoord", "a_Position"],
uniforms:["world", "view", "projection", "color_tex"]}
];
var entities = [];
var shaderProgramIds = [];
var position = [0.0, 0.0, 0.0];
var direction = [0.0,0.0, -1.0];
var options = {tickSpeed:20};
async function main() {


  let canvas = document.getElementById("gameBoard");
  var gl = canvas.getContext("webgl2");
canvas.addEventListener("click", async () => {
await canvas.requestPointerLock({
unadjustedMovement: true,
});
});
 let texture = loadTexFromImage(gl, "data:image/jpeg;base64,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")
gl.bindTexture(gl.TEXTURE_2D, texture.texture);

gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, null);

initLoadingScreen(gl);
initControls();
 downloadAssets(`data:text,{assets:{}, assetList:{}}`);


entities.push(newEntity([0.0, 0.0, -8.0], [0.0, 0.0, 0.0], [1.0, 1.0, 1.0], 0, 36,
function(current){return{position:current.position, rotation:current.rotation,scale:[1.0, 1.0,
1.0],vaoId:current.vaoId, numIndicies:current.numIndicies, tick:current.tick}}))
 processAssets(gl);
  startTick();
console.log(gl.getError(), gl.UNSIGNED_SHORT, gl.UNSIGNED_BYTE);



}
function startTick(){
setTimeout(mainTick,(1/options.tickSpeed) * 1000);
}
function mainTick(){
  for(let i = 0;i<entities.length;i++){
  entities[i] = entities[i].tick(entities[i]);
  }
  setTimeout(mainTick,(1/options.tickSpeed) * 1000);

}

function initLoadingScreen(gl) {

 


  let shaderProgram = createProgram(gl, createVertexShader(gl, loadingScreen.vertexShader), createFragmentShader(gl, loadingScreen.fragmentShader));



  let vertexBuffer = createVertexBuffer(gl, loadingScreen.vertexData, gl.STATIC_DRAW, Float32Array);


  let indexBuffer = createIndexBuffer(gl, loadingScreen.indexData, gl.STATIC_DRAW, Uint8Array);



  let vao = createVao(gl);


  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

  gl.vertexAttribPointer(0, loadingScreen.vertexSize, gl.FLOAT, loadingScreen.vertexNormal, loadingScreen.vertexStride * 4, loadingScreen.vertexOffset);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);


  gl.bindVertexArray(null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);



  let uniformLocations = getUniformLocations(gl, shaderProgram, loadingScreen.numUniformLocations, loadingScreen.uniformNames);
  let attribLocations = getAttribLocations(gl, shaderProgram, 1, loadingScreen.attribName);

  




  requestAnimationFrame(loadingScreenRender.bind(null, gl, shaderProgram, vao, uniformLocations, attribLocations, undefined, 0));

}
function loadingScreenRender(gl, shaderProgram, vao, uniformLocations, attribLocations, time, previousTime) {
  let timeStamp = performance.now() - previousTime;





  resize(gl.canvas);

  clear(gl);

  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(shaderProgram);
enableAttribLocations(gl, 1, attribLocations);
  gl.uniform2fv(uniformLocations[1], new Float32Array([gl.canvas.width, gl.canvas.height]));
  gl.uniform1fv(uniformLocations[0], new Float32Array([percentage]));

gl.uniform1i(uniformLocations[2], 0);

  gl.bindVertexArray(vao);

  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);


  if (percentage + 0.0000000000001 <= 1.0) {
    requestAnimationFrame(loadingScreenRender.bind(null, gl, shaderProgram, vao, uniformLocations, attribLocations, 0, timeStamp));
  
  }else{
    
    setTimeout(function(){
   render(gl);
    }, 500)
  }


}

function processAssets(gl) {

  for (let i = 0; i < assetList.length; i++) {
    switch (assetList[i].fileType) {
      case "image":
        
          files.push({ data: assetList[i].url, type: assetList[i].type });
        
            percentage += (1 / (assetList.length + 2)) * 0.5;

      
        break;
      case "text":
       let textData = assetList[i];
        files.push({data: assets[textData.data], type: textData.type, usage: textData.usage, arrayType:textData.arrayType || null});
        
  percentage += (1 / (assetList.length + 2)) * 0.5;
            
        break;
    }
  }
   
setTimeout(function(){
      percentage += (1 / (assetList.length + 2)) * 0.5;
	percentage += (1 / (assetList.length + 2)) * 0.5;
   }, percentage * 2500)


  let renderer = [];
  for (let i = 0; i < files.length; i++) {
     switch (files[i].type) {
      case "vertexShader":
        renderer.push(createVertexShader(gl, files[i].data.data));
       
     
        break;
      case "fragmentShader":
       renderer.push(createFragmentShader(gl, files[i].data.data));
        break;
      case "vertexBuffer":
        renderer.push(createVertexBuffer(gl, files[i].data.data, files[i].usage, files[i].arrayType));
      
        break;
      case "indexBuffer":
        renderer.push(createIndexBuffer(gl, files[i].data.data, files[i].usage, files[i].arrayType));
        break;
      case "texture":
      
        renderer.push(loadTexFromImage(gl, files[i].data));
        break;

    }
    setTimeout(function(){percentage += (1 / (files.length)) * 0.5}, percentage * 2000);
  
  }
   files = renderer;
  
   
   

  for(let i = 0;i<shaderPrograms.length;i++){

shaderProgramIds.push({data:createProgram(gl, files[shaderPrograms[i].vertexShader], files[shaderPrograms[i].fragmentShader]), attribLocations:[], uniformLocations:[]});


   shaderProgramIds[shaderProgramIds.length - 1].attribLocations = {data: getAttribLocations(gl, shaderProgramIds[shaderProgramIds.length - 1].data, shaderPrograms[i].attributes.length, shaderPrograms[i].attributes), names: shaderPrograms[i].attributes};

shaderProgramIds[shaderProgramIds.length - 1].uniformLocations = {data: getUniformLocations(gl, shaderProgramIds[shaderProgramIds.length - 1].data, shaderPrograms[i].uniforms.length, shaderPrograms[i].uniforms), names: shaderPrograms[i].uniforms};


  }

    
  for (let i = 0; i < vaos.length; i++) {

    vaoIds.push(createVao(gl));
   


   
    
 

 for(let x = 0;x<vaos[i].attribs.length;x++){

      gl.bindBuffer(gl.ARRAY_BUFFER, files[vaos[i].attribs[x].num]);
       
    gl.vertexAttribPointer(shaderProgramIds[vaos[i].shaderProgram].attribLocations.data[x], vaos[i].attribs[x].size, vaos[i].attribs[x].type, vaos[i].attribs[x].normalized, vaos[i].attribs[x].stride, vaos[i].attribs[x].offset);
 
 
   
       }
        
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, files[vaos[i].indexBuffer]);
    
    gl.bindVertexArray(null);

  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

}
 function initControls(){
   document.addEventListener("mousemove", function(event){mouseX += event.movementX; mouseY += event.movementY; let rate = 25000;cameraRotation[0] += event.movementY / rate;cameraRotation[1] += event.movementX / rate;console.log(cameraRotation)})
 
     document.addEventListener("keydown", function(event){
       direction[1] = -Math.sin((-cameraRotation[0]) / Math.PI * 180) * direction[2] + Math.cos((-cameraRotation[0]) / Math.PI * 180) * direction[1];direction[2] = (Math.cos((-cameraRotation[0]) / Math.PI * 180)) * direction[2] + (Math.sin((-cameraRotation[0]) / Math.PI * 180)) * direction[1] ;direction[0] = -Math.sin((cameraRotation[1]) / Math.PI * 180) * direction[2] + Math.cos((cameraRotation[1]) / Math.PI * 180) * direction[0];direction[2] = (Math.cos((cameraRotation[1]) / Math.PI * 180)) * direction[2] + Math.sin((cameraRotation[1]) / Math.PI * 180) * direction[0] ; 

     let dir = Mat4.normalize([direction[0], 0.0, direction[2]]);
    
     if(event.shiftKey){
position[1] -=0.625
     }
     switch(event.key){
case"w":

for(let i = 0;i<3;i++){
position[i] += dir[i] * 0.625 
}
break;
case"s":

for(let i = 0;i<3;i++){
position[i] -= dir[i] * 0.625 
}
break;
case " ":
position[1] +=0.625
break;
     }
     direction = [0.0, 0.0, -5.0]
   });
 } 
 
function render(gl){


function mainRender(previousTime, camera) {
let timestamp = performance.now() - previousTime

direction[1] = -Math.sin((-cameraRotation[0]) / Math.PI * 180) * direction[2] + Math.cos((-cameraRotation[0]) / Math.PI * 180) * direction[1];direction[2] = (Math.cos((-cameraRotation[0]) / Math.PI * 180)) * direction[2] + (Math.sin((-cameraRotation[0]) / Math.PI * 180)) * direction[1] ;direction[0] = -Math.sin((cameraRotation[1]) / Math.PI * 180) * direction[2] + Math.cos((cameraRotation[1]) / Math.PI * 180) * direction[0];direction[2] = (Math.cos((cameraRotation[1]) / Math.PI * 180)) * direction[2] + Math.sin((cameraRotation[1]) / Math.PI * 180) * direction[0] ; 
resize(gl.canvas)
clear(gl);
gl.viewport(0,0, gl.canvas.width, gl.canvas.height);

gl.useProgram(shaderProgramIds[0].data);
gl.enableVertexAttribArray(0);
gl.enableVertexAttribArray(1);
gl.enable(gl.DEPTH_TEST);
 gl.enable(gl.CULL_FACE);
 for(let i = 0;i<entities.length;i++){
   gl.uniformMatrix4fv(shaderProgramIds[0].uniformLocations.data[shaderProgramIds[0].uniformLocations.names.indexOf("projection")], false, new Float32Array(Mat4.perspective(90, gl.canvas.width / gl.canvas.height, 0.01, 1000)));
gl.uniformMatrix4fv(shaderProgramIds[0].uniformLocations.data[shaderProgramIds[0].uniformLocations.names.indexOf("view")], false, new Float32Array(Mat4.inverse(Mat4.lookAt(position, Mat4.addVectors(direction, position), [0.0, 1.0, 0.0]))));

gl.bindVertexArray(vaoIds[entities[i].vaoId]);


 
    var matrix = Mat4.translate(Mat4.identity(), entities[i].position[0], entities[i].position[1], entities[i].position[2]);
    matrix = Mat4.xRotate(matrix, entities[i].rotation[0]);
    matrix = Mat4.yRotate(matrix,entities[i].rotation[1]);
    matrix = Mat4.zRotate(matrix, entities[i].rotation[2]);
    matrix = Mat4.scale(matrix, entities[i].scale[0], entities[i].scale[1], entities[i].scale[2]);
gl.uniformMatrix4fv(shaderProgramIds[0].uniformLocations.data[shaderProgramIds[0].uniformLocations.names.indexOf("world")], false, new Float32Array(matrix))
gl.uniform1i(shaderProgramIds[0].uniformLocations.data[shaderProgramIds[0].uniformLocations.names.indexOf("color_tex")], 1);
gl.drawElements(gl.TRIANGLES, entities[i].numIndicies, gl.UNSIGNED_SHORT, 0)
 
 }
 direction = [0.0, 0.0, -5.0]
 for(let i = 0;i<texts.length;i++){

 }
  requestAnimationFrame(mainRender.bind(timestamp, camera));
  
}


requestAnimationFrame(mainRender.bind(0, new Camera()));

}
function uiRender(uis) {

}
function particleRender() {

}
function shadowMapRenderer() {

}
function clear(gl) {
  gl.clearColor(0.5, 1.0, 1.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}
function resize(viewport) {
  viewport.height = window.innerHeight;
  viewport.width = window.innerWidth;
  return viewport;
}


function createVertexShader(gl, sourceCode) {

  let shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(shader, sourceCode);
  gl.compileShader(shader);
  return shader;
}
function createFragmentShader(gl, sourceCode) {
  let shader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(shader, sourceCode);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl, vs, fs) {
  let program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.validateProgram(program);
  return program;

}
function createVertexBuffer(gl, data, usage, arrayType) {
  let buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new arrayType(data), usage);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return buffer;
}
function createIndexBuffer(gl, data, usage, arrayType) {
  let buffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new arrayType(data), usage);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  return buffer;
}
function loadTexFromImage(gl, url) {
  let tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255]));

  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  let image = new Image();
  image.crossOrigin = "anonymous"
  var textureInfo = {
    width: 3,   // we don't know the size until it loads
    height: 3,
    texture: tex,
  };
  image.addEventListener("load", function () {
    textureInfo.width = image.width;
    textureInfo.height = image.height;

    gl.bindTexture(gl.TEXTURE_2D, textureInfo.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.activeTexture(gl.TEXTURE0 + 1);
  });
  image.src = url;
  return textureInfo;
}
function createVao(gl) {
  let vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  return vao;
}
function getUniformLocations(gl, shaderProgram, numLocations, names) {
  let uniformLocation = [];
  for (let i = 0; i < numLocations; i++) {
    uniformLocation[i] = gl.getUniformLocation(shaderProgram, names[i]);
  }
  return uniformLocation;
}
function getAttribLocations(gl, shaderProgram, numLocations, names) {
  let attribLocations = [];
  for (let ii = 0; ii < numLocations; ii++) {
    attribLocations[ii] = gl.getAttribLocation(shaderProgram, names[ii]);
  }
  return attribLocations;
}
function enableAttribLocations(gl, numlocations, locations) {
  for (let i = 0; i < numlocations; i++) {
    gl.enableVertexAttribArray(locations[i]);
  }
}


  main();

  

function parseOBJ(text) {
  // because indices are base 1 let's just fill in the 0th data
  const objPositions = [[0, 0, 0]];
  const objTexcoords = [[0, 0]];
  const objNormals = [[0, 0, 0]];

  // same order as `f` indices
  const objVertexData = [
    objPositions,
    objTexcoords,
    objNormals,
  ];

  // same order as `f` indices
  let webglVertexData = [
    [],   // positions
    [],   // texcoords
    [],   // normals
  ];

  function newGeometry() {
    
    if (geometry && geometry.data.position.length) {
      geometry = undefined;
    }
    setGeometry();
  }

  function addVertex(vert) {
    const ptn = vert.split('/');
    ptn.forEach((objIndexStr, i) => {
      if (!objIndexStr) {
        return;
      }
      const objIndex = parseInt(objIndexStr);
      const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
      webglVertexData[i].push(...objVertexData[i][index]);
    });
  }

  const keywords = {
    v(parts) {
      objPositions.push(parts.map(parseFloat));
    },
    vn(parts) {
      objNormals.push(parts.map(parseFloat));
    },
    vt(parts) {
      // should check for missing v and extra w?
      objTexcoords.push(parts.map(parseFloat));
    },
    f(parts) {
      const numTriangles = parts.length - 2;
      for (let tri = 0; tri < numTriangles; ++tri) {
        addVertex(parts[0]);
        addVertex(parts[tri + 1]);
        addVertex(parts[tri + 2]);
      }
    },
  };

  const keywordRE = /(\w*)(?: )*(.*)/;
  const lines = text.split('\n');
  for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
    const line = lines[lineNo].trim();
    if (line === '' || line.startsWith('#')) {
      continue;
    }
    const m = keywordRE.exec(line);
    if (!m) {
      continue;
    }
    const [, keyword, unparsedArgs] = m;
    const parts = line.split(/\s+/).slice(1);
    const handler = keywords[keyword];
    if (!handler) {
      continue;
    }
    handler(parts, unparsedArgs);
  }

  return {
    position: webglVertexData[0],
    texcoord: webglVertexData[1],
    normal: webglVertexData[2],
  };
}


function newEntity(position, rotation, scale, vaoId, numIndicies, tick){
return{position:position || [0.0, 0.0, 0.0], rotation:rotation  || [0.0, 0.0, 0.0],scale:scale  || [1.0, 1.0, 1.0],vaoId:vaoId || 0, numIndicies:numIndicies || 0, tick:tick || function(){}}
}
class Camera{
  constructor(){
    this.position = new Vec3();
    this.pitch;
    this.yaw;
  }
}
class Model{
  constructor(vao, texture, properties){
this.vao = vao;
this.texture = texture;
this.properties = properties;
  }

}
class Vec3{
  constructor(data){
if(data){
  this.x = data[0];
  this.y = data[1];
  this.z = data[2];
}else{
  this.x = 0;
  this.y = 0;
  this.z = 0;
}
  }
  sub(data){
    this.x -= data[0];
    this.y -= data[1];
    this.z -= data[2];
  }
   add(data){
    this.x += data[0];
    this.y += data[1];
    this.z += data[2];
  }
  static normalize(vector){
    let magnitude = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]);
    vector[0] /= magnitude;
    vector[1] /= magnitude;
    vector[2] /= magnitude;
    return vector;
  }
  static cross(a, b){
    
return new vec3((a[1] * b[2] - a[2] * b[1]), (a[0] * b[2] - a[2] * b[0]), (a[0] * b[1] - a[1] * b[0]));
  }
  static dot(a, b){
return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  set(data){
this.x = data[0];
  this.y = data[1];
  this.z = data[2];
  }
  get vector(){
    return [this.x, this.y, this.z];
  }
}


 /* Copyright 2021 GFXFundamentals.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of GFXFundamentals. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Various 3d math functions.
 *
 * 
 */

let mat4 =  function () {
  "use strict";

  /**
   * An array or typed array with 3 values.
   * @typedef {number[]|TypedArray} Vector3
   * @memberOf module:webgl-3d-math
   */

  /**
   * An array or typed array with 4 values.
   * @typedef {number[]|TypedArray} Vector4
   * @memberOf module:webgl-3d-math
   */

  /**
   * An array or typed array with 16 values.
   * @typedef {number[]|TypedArray} Matrix4
   * @memberOf module:webgl-3d-math
   */


  let MatType = Float32Array;

  /**
   * Sets the type this library creates for a Mat4
   * @param {constructor} Ctor the constructor for the type. Either `Float32Array` or `Array`
   * @return {constructor} previous constructor for Mat4
   */
  function setDefaultType(Ctor) {
    const OldType = MatType;
    MatType = Ctor;
    return OldType;
  }

  /**
   * Takes two 4-by-4 matrices, a and b, and computes the product in the order
   * that pre-composes b with a.  In other words, the matrix returned will
   * transform by b first and then a.  Note this is subtly different from just
   * multiplying the matrices together.  For given a and b, this function returns
   * the same object in both row-major and column-major mode.
   * @param {Matrix4} a A matrix.
   * @param {Matrix4} b A matrix.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   */
  function multiply(a, b, dst) {
    dst = dst || new MatType(16);
    var b00 = b[0 * 4 + 0];
    var b01 = b[0 * 4 + 1];
    var b02 = b[0 * 4 + 2];
    var b03 = b[0 * 4 + 3];
    var b10 = b[1 * 4 + 0];
    var b11 = b[1 * 4 + 1];
    var b12 = b[1 * 4 + 2];
    var b13 = b[1 * 4 + 3];
    var b20 = b[2 * 4 + 0];
    var b21 = b[2 * 4 + 1];
    var b22 = b[2 * 4 + 2];
    var b23 = b[2 * 4 + 3];
    var b30 = b[3 * 4 + 0];
    var b31 = b[3 * 4 + 1];
    var b32 = b[3 * 4 + 2];
    var b33 = b[3 * 4 + 3];
    var a00 = a[0 * 4 + 0];
    var a01 = a[0 * 4 + 1];
    var a02 = a[0 * 4 + 2];
    var a03 = a[0 * 4 + 3];
    var a10 = a[1 * 4 + 0];
    var a11 = a[1 * 4 + 1];
    var a12 = a[1 * 4 + 2];
    var a13 = a[1 * 4 + 3];
    var a20 = a[2 * 4 + 0];
    var a21 = a[2 * 4 + 1];
    var a22 = a[2 * 4 + 2];
    var a23 = a[2 * 4 + 3];
    var a30 = a[3 * 4 + 0];
    var a31 = a[3 * 4 + 1];
    var a32 = a[3 * 4 + 2];
    var a33 = a[3 * 4 + 3];
    dst[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
    dst[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
    dst[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
    dst[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
    dst[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
    dst[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
    dst[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
    dst[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
    dst[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
    dst[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
    dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
    dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
    dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
    dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
    dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
    dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    return dst;
  }


  /**
   * adds 2 vectors3s
   * @param {Vector3} a a
   * @param {Vector3} b b
   * @param {Vector3} dst optional vector3 to store result
   * @return {Vector3} dst or new Vector3 if not provided
   * @memberOf module:webgl-3d-math
   */
  function addVectors(a, b, dst) {
    dst = dst || new MatType(3);
    dst[0] = a[0] + b[0];
    dst[1] = a[1] + b[1];
    dst[2] = a[2] + b[2];
    return dst;
  }

  /**
   * subtracts 2 vectors3s
   * @param {Vector3} a a
   * @param {Vector3} b b
   * @param {Vector3} dst optional vector3 to store result
   * @return {Vector3} dst or new Vector3 if not provided
   * @memberOf module:webgl-3d-math
   */
  function subtractVectors(a, b, dst) {
    dst = dst || new MatType(3);
    dst[0] = a[0] - b[0];
    dst[1] = a[1] - b[1];
    dst[2] = a[2] - b[2];
    return dst;
  }

  /**
   * scale vectors3
   * @param {Vector3} v vector
   * @param {Number} s scale
   * @param {Vector3} dst optional vector3 to store result
   * @return {Vector3} dst or new Vector3 if not provided
   * @memberOf module:webgl-3d-math
   */
  function scaleVector(v, s, dst) {
    dst = dst || new MatType(3);
    dst[0] = v[0] * s;
    dst[1] = v[1] * s;
    dst[2] = v[2] * s;
    return dst;
  }

  /**
   * normalizes a vector.
   * @param {Vector3} v vector to normalize
   * @param {Vector3} dst optional vector3 to store result
   * @return {Vector3} dst or new Vector3 if not provided
   * @memberOf module:webgl-3d-math
   */
  function normalize(v, dst) {
    dst = dst || new MatType(3);
    var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    // make sure we don't divide by 0.
    if (length > 0.00001) {
      dst[0] = v[0] / length;
      dst[1] = v[1] / length;
      dst[2] = v[2] / length;
    }
    return dst;
  }

  /**
   * Computes the length of a vector
   * @param {Vector3} v vector to take length of
   * @return {number} length of vector
   */
  function length(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  }

  /**
   * Computes the length squared of a vector
   * @param {Vector3} v vector to take length of
   * @return {number} length sqaured of vector
   */
  function lengthSq(v) {
    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
  }

  /**
   * Computes the cross product of 2 vectors3s
   * @param {Vector3} a a
   * @param {Vector3} b b
   * @param {Vector3} dst optional vector3 to store result
   * @return {Vector3} dst or new Vector3 if not provided
   * @memberOf module:webgl-3d-math
   */
  function cross(a, b, dst) {
    dst = dst || new MatType(3);
    dst[0] = a[1] * b[2] - a[2] * b[1];
    dst[1] = a[2] * b[0] - a[0] * b[2];
    dst[2] = a[0] * b[1] - a[1] * b[0];
    return dst;
  }

  /**
   * Computes the dot product of two vectors; assumes both vectors have
   * three entries.
   * @param {Vector3} a Operand vector.
   * @param {Vector3} b Operand vector.
   * @return {number} dot product
   * @memberOf module:webgl-3d-math
   */
  function dot(a, b) {
    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
  }

  /**
   * Computes the distance squared between 2 points
   * @param {Vector3} a
   * @param {Vector3} b
   * @return {number} distance squared between a and b
   */
  function distanceSq(a, b) {
    const dx = a[0] - b[0];
    const dy = a[1] - b[1];
    const dz = a[2] - b[2];
    return dx * dx + dy * dy + dz * dz;
  }

  /**
   * Computes the distance between 2 points
   * @param {Vector3} a
   * @param {Vector3} b
   * @return {number} distance between a and b
   */
  function distance(a, b) {
    return Math.sqrt(distanceSq(a, b));
  }

  /**
   * Makes an identity matrix.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function identity(dst) {
    dst = dst || new MatType(16);

    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 1;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;

    return dst;
  }

  /**
   * Transposes a matrix.
   * @param {Matrix4} m matrix to transpose.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function transpose(m, dst) {
    dst = dst || new MatType(16);

    dst[0] = m[0];
    dst[1] = m[4];
    dst[2] = m[8];
    dst[3] = m[12];
    dst[4] = m[1];
    dst[5] = m[5];
    dst[6] = m[9];
    dst[7] = m[13];
    dst[8] = m[2];
    dst[9] = m[6];
    dst[10] = m[10];
    dst[11] = m[14];
    dst[12] = m[3];
    dst[13] = m[7];
    dst[14] = m[11];
    dst[15] = m[15];

    return dst;
  }

  /**
   * Creates a lookAt matrix.
   * This is a world matrix for a camera. In other words it will transform
   * from the origin to a place and orientation in the world. For a view
   * matrix take the inverse of this.
   * @param {Vector3} cameraPosition position of the camera
   * @param {Vector3} target position of the target
   * @param {Vector3} up direction
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function lookAt(cameraPosition, target, up, dst) {
    dst = dst || new MatType(16);
    var zAxis = normalize(
      subtractVectors(cameraPosition, target));
    var xAxis = normalize(cross(up, zAxis));
    var yAxis = normalize(cross(zAxis, xAxis));

    dst[0] = xAxis[0];
    dst[1] = xAxis[1];
    dst[2] = xAxis[2];
    dst[3] = 0;
    dst[4] = yAxis[0];
    dst[5] = yAxis[1];
    dst[6] = yAxis[2];
    dst[7] = 0;
    dst[8] = zAxis[0];
    dst[9] = zAxis[1];
    dst[10] = zAxis[2];
    dst[11] = 0;
    dst[12] = cameraPosition[0];
    dst[13] = cameraPosition[1];
    dst[14] = cameraPosition[2];
    dst[15] = 1;

    return dst;
  }

  /**
   * Computes a 4-by-4 perspective transformation matrix given the angular height
   * of the frustum, the aspect ratio, and the near and far clipping planes.  The
   * arguments define a frustum extending in the negative z direction.  The given
   * angle is the vertical angle of the frustum, and the horizontal angle is
   * determined to produce the given aspect ratio.  The arguments near and far are
   * the distances to the near and far clipping planes.  Note that near and far
   * are not z coordinates, but rather they are distances along the negative
   * z-axis.  The matrix generated sends the viewing frustum to the unit box.
   * We assume a unit box extending from -1 to 1 in the x and y dimensions and
   * from -1 to 1 in the z dimension.
   * @param {number} fieldOfViewInRadians field of view in y axis.
   * @param {number} aspect aspect of viewport (width / height)
   * @param {number} near near Z clipping plane
   * @param {number} far far Z clipping plane
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function perspective(fieldOfViewInRadians, aspect, near, far, dst) {
    dst = dst || new MatType(16);
    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
    var rangeInv = 1.0 / (near - far);

    dst[0] = f / aspect;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = f;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = (near + far) * rangeInv;
    dst[11] = -1;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = near * far * rangeInv * 2;
    dst[15] = 0;

    return dst;
  }

  /**
   * Computes a 4-by-4 orthographic projection matrix given the coordinates of the
   * planes defining the axis-aligned, box-shaped viewing volume.  The matrix
   * generated sends that box to the unit box.  Note that although left and right
   * are x coordinates and bottom and top are y coordinates, near and far
   * are not z coordinates, but rather they are distances along the negative
   * z-axis.  We assume a unit box extending from -1 to 1 in the x and y
   * dimensions and from -1 to 1 in the z dimension.
   * @param {number} left The x coordinate of the left plane of the box.
   * @param {number} right The x coordinate of the right plane of the box.
   * @param {number} bottom The y coordinate of the bottom plane of the box.
   * @param {number} top The y coordinate of the right plane of the box.
   * @param {number} near The negative z coordinate of the near plane of the box.
   * @param {number} far The negative z coordinate of the far plane of the box.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function orthographic(left, right, bottom, top, near, far, dst) {
    dst = dst || new MatType(16);

    dst[0] = 2 / (right - left);
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 2 / (top - bottom);
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 2 / (near - far);
    dst[11] = 0;
    dst[12] = (left + right) / (left - right);
    dst[13] = (bottom + top) / (bottom - top);
    dst[14] = (near + far) / (near - far);
    dst[15] = 1;

    return dst;
  }

  /**
   * Computes a 4-by-4 perspective transformation matrix given the left, right,
   * top, bottom, near and far clipping planes. The arguments define a frustum
   * extending in the negative z direction. The arguments near and far are the
   * distances to the near and far clipping planes. Note that near and far are not
   * z coordinates, but rather they are distances along the negative z-axis. The
   * matrix generated sends the viewing frustum to the unit box. We assume a unit
   * box extending from -1 to 1 in the x and y dimensions and from -1 to 1 in the z
   * dimension.
   * @param {number} left The x coordinate of the left plane of the box.
   * @param {number} right The x coordinate of the right plane of the box.
   * @param {number} bottom The y coordinate of the bottom plane of the box.
   * @param {number} top The y coordinate of the right plane of the box.
   * @param {number} near The negative z coordinate of the near plane of the box.
   * @param {number} far The negative z coordinate of the far plane of the box.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function frustum(left, right, bottom, top, near, far, dst) {
    dst = dst || new MatType(16);

    var dx = right - left;
    var dy = top - bottom;
    var dz = far - near;

    dst[0] = 2 * near / dx;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 2 * near / dy;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = (left + right) / dx;
    dst[9] = (top + bottom) / dy;
    dst[10] = -(far + near) / dz;
    dst[11] = -1;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = -2 * near * far / dz;
    dst[15] = 0;

    return dst;
  }

  /**
   * Makes a translation matrix
   * @param {number} tx x translation.
   * @param {number} ty y translation.
   * @param {number} tz z translation.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function translation(tx, ty, tz, dst) {
    dst = dst || new MatType(16);

    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 1;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1;
    dst[11] = 0;
    dst[12] = tx;
    dst[13] = ty;
    dst[14] = tz;
    dst[15] = 1;

    return dst;
  }

  /**
   * Multiply by translation matrix.
   * @param {Matrix4} m matrix to multiply
   * @param {number} tx x translation.
   * @param {number} ty y translation.
   * @param {number} tz z translation.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function translate(m, tx, ty, tz, dst) {
    // This is the optimized version of
    // return multiply(m, translation(tx, ty, tz), dst);
    dst = dst || new MatType(16);

    var m00 = m[0];
    var m01 = m[1];
    var m02 = m[2];
    var m03 = m[3];
    var m10 = m[1 * 4 + 0];
    var m11 = m[1 * 4 + 1];
    var m12 = m[1 * 4 + 2];
    var m13 = m[1 * 4 + 3];
    var m20 = m[2 * 4 + 0];
    var m21 = m[2 * 4 + 1];
    var m22 = m[2 * 4 + 2];
    var m23 = m[2 * 4 + 3];
    var m30 = m[3 * 4 + 0];
    var m31 = m[3 * 4 + 1];
    var m32 = m[3 * 4 + 2];
    var m33 = m[3 * 4 + 3];

    if (m !== dst) {
      dst[0] = m00;
      dst[1] = m01;
      dst[2] = m02;
      dst[3] = m03;
      dst[4] = m10;
      dst[5] = m11;
      dst[6] = m12;
      dst[7] = m13;
      dst[8] = m20;
      dst[9] = m21;
      dst[10] = m22;
      dst[11] = m23;
    }

    dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;
    dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;
    dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;
    dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;

    return dst;
  }

  /**
   * Makes an x rotation matrix
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function xRotation(angleInRadians, dst) {
    dst = dst || new MatType(16);
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = c;
    dst[6] = s;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = -s;
    dst[10] = c;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;

    return dst;
  }

  /**
   * Multiply by an x rotation matrix
   * @param {Matrix4} m matrix to multiply
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function xRotate(m, angleInRadians, dst) {
    // this is the optimized version of
    // return multiply(m, xRotation(angleInRadians), dst);
    dst = dst || new MatType(16);

    var m10 = m[4];
    var m11 = m[5];
    var m12 = m[6];
    var m13 = m[7];
    var m20 = m[8];
    var m21 = m[9];
    var m22 = m[10];
    var m23 = m[11];
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    dst[4] = c * m10 + s * m20;
    dst[5] = c * m11 + s * m21;
    dst[6] = c * m12 + s * m22;
    dst[7] = c * m13 + s * m23;
    dst[8] = c * m20 - s * m10;
    dst[9] = c * m21 - s * m11;
    dst[10] = c * m22 - s * m12;
    dst[11] = c * m23 - s * m13;

    if (m !== dst) {
      dst[0] = m[0];
      dst[1] = m[1];
      dst[2] = m[2];
      dst[3] = m[3];
      dst[12] = m[12];
      dst[13] = m[13];
      dst[14] = m[14];
      dst[15] = m[15];
    }

    return dst;
  }

  /**
   * Makes an y rotation matrix
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function yRotation(angleInRadians, dst) {
    dst = dst || new MatType(16);
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    dst[0] = c;
    dst[1] = 0;
    dst[2] = -s;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 1;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = s;
    dst[9] = 0;
    dst[10] = c;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;

    return dst;
  }

  /**
   * Multiply by an y rotation matrix
   * @param {Matrix4} m matrix to multiply
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function yRotate(m, angleInRadians, dst) {
    // this is the optimized version of
    // return multiply(m, yRotation(angleInRadians), dst);
    dst = dst || new MatType(16);

    var m00 = m[0 * 4 + 0];
    var m01 = m[0 * 4 + 1];
    var m02 = m[0 * 4 + 2];
    var m03 = m[0 * 4 + 3];
    var m20 = m[2 * 4 + 0];
    var m21 = m[2 * 4 + 1];
    var m22 = m[2 * 4 + 2];
    var m23 = m[2 * 4 + 3];
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    dst[0] = c * m00 - s * m20;
    dst[1] = c * m01 - s * m21;
    dst[2] = c * m02 - s * m22;
    dst[3] = c * m03 - s * m23;
    dst[8] = c * m20 + s * m00;
    dst[9] = c * m21 + s * m01;
    dst[10] = c * m22 + s * m02;
    dst[11] = c * m23 + s * m03;

    if (m !== dst) {
      dst[4] = m[4];
      dst[5] = m[5];
      dst[6] = m[6];
      dst[7] = m[7];
      dst[12] = m[12];
      dst[13] = m[13];
      dst[14] = m[14];
      dst[15] = m[15];
    }

    return dst;
  }

  /**
   * Makes an z rotation matrix
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function zRotation(angleInRadians, dst) {
    dst = dst || new MatType(16);
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    dst[0] = c;
    dst[1] = s;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = -s;
    dst[5] = c;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;

    return dst;
  }

  /**
   * Multiply by an z rotation matrix
   * @param {Matrix4} m matrix to multiply
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function zRotate(m, angleInRadians, dst) {
    // This is the optimized version of
    // return multiply(m, zRotation(angleInRadians), dst);
    dst = dst || new MatType(16);

    var m00 = m[0 * 4 + 0];
    var m01 = m[0 * 4 + 1];
    var m02 = m[0 * 4 + 2];
    var m03 = m[0 * 4 + 3];
    var m10 = m[1 * 4 + 0];
    var m11 = m[1 * 4 + 1];
    var m12 = m[1 * 4 + 2];
    var m13 = m[1 * 4 + 3];
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);

    dst[0] = c * m00 + s * m10;
    dst[1] = c * m01 + s * m11;
    dst[2] = c * m02 + s * m12;
    dst[3] = c * m03 + s * m13;
    dst[4] = c * m10 - s * m00;
    dst[5] = c * m11 - s * m01;
    dst[6] = c * m12 - s * m02;
    dst[7] = c * m13 - s * m03;

    if (m !== dst) {
      dst[8] = m[8];
      dst[9] = m[9];
      dst[10] = m[10];
      dst[11] = m[11];
      dst[12] = m[12];
      dst[13] = m[13];
      dst[14] = m[14];
      dst[15] = m[15];
    }

    return dst;
  }

  /**
   * Makes an rotation matrix around an arbitrary axis
   * @param {Vector3} axis axis to rotate around
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function axisRotation(axis, angleInRadians, dst) {
    dst = dst || new MatType(16);

    var x = axis[0];
    var y = axis[1];
    var z = axis[2];
    var n = Math.sqrt(x * x + y * y + z * z);
    x /= n;
    y /= n;
    z /= n;
    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);
    var oneMinusCosine = 1 - c;

    dst[0] = xx + (1 - xx) * c;
    dst[1] = x * y * oneMinusCosine + z * s;
    dst[2] = x * z * oneMinusCosine - y * s;
    dst[3] = 0;
    dst[4] = x * y * oneMinusCosine - z * s;
    dst[5] = yy + (1 - yy) * c;
    dst[6] = y * z * oneMinusCosine + x * s;
    dst[7] = 0;
    dst[8] = x * z * oneMinusCosine + y * s;
    dst[9] = y * z * oneMinusCosine - x * s;
    dst[10] = zz + (1 - zz) * c;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;

    return dst;
  }

  /**
   * Multiply by an axis rotation matrix
   * @param {Matrix4} m matrix to multiply
   * @param {Vector3} axis axis to rotate around
   * @param {number} angleInRadians amount to rotate
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function axisRotate(m, axis, angleInRadians, dst) {
    // This is the optimized version of
    // return multiply(m, axisRotation(axis, angleInRadians), dst);
    dst = dst || new MatType(16);

    var x = axis[0];
    var y = axis[1];
    var z = axis[2];
    var n = Math.sqrt(x * x + y * y + z * z);
    x /= n;
    y /= n;
    z /= n;
    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);
    var oneMinusCosine = 1 - c;

    var r00 = xx + (1 - xx) * c;
    var r01 = x * y * oneMinusCosine + z * s;
    var r02 = x * z * oneMinusCosine - y * s;
    var r10 = x * y * oneMinusCosine - z * s;
    var r11 = yy + (1 - yy) * c;
    var r12 = y * z * oneMinusCosine + x * s;
    var r20 = x * z * oneMinusCosine + y * s;
    var r21 = y * z * oneMinusCosine - x * s;
    var r22 = zz + (1 - zz) * c;

    var m00 = m[0];
    var m01 = m[1];
    var m02 = m[2];
    var m03 = m[3];
    var m10 = m[4];
    var m11 = m[5];
    var m12 = m[6];
    var m13 = m[7];
    var m20 = m[8];
    var m21 = m[9];
    var m22 = m[10];
    var m23 = m[11];

    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;

    if (m !== dst) {
      dst[12] = m[12];
      dst[13] = m[13];
      dst[14] = m[14];
      dst[15] = m[15];
    }

    return dst;
  }

  /**
   * Makes a scale matrix
   * @param {number} sx x scale.
   * @param {number} sy y scale.
   * @param {number} sz z scale.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function scaling(sx, sy, sz, dst) {
    dst = dst || new MatType(16);

    dst[0] = sx;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = sy;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = sz;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;

    return dst;
  }

  /**
   * Multiply by a scaling matrix
   * @param {Matrix4} m matrix to multiply
   * @param {number} sx x scale.
   * @param {number} sy y scale.
   * @param {number} sz z scale.
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function scale(m, sx, sy, sz, dst) {
    // This is the optimized version of
    // return multiply(m, scaling(sx, sy, sz), dst);
    dst = dst || new MatType(16);

    dst[0] = sx * m[0 * 4 + 0];
    dst[1] = sx * m[0 * 4 + 1];
    dst[2] = sx * m[0 * 4 + 2];
    dst[3] = sx * m[0 * 4 + 3];
    dst[4] = sy * m[1 * 4 + 0];
    dst[5] = sy * m[1 * 4 + 1];
    dst[6] = sy * m[1 * 4 + 2];
    dst[7] = sy * m[1 * 4 + 3];
    dst[8] = sz * m[2 * 4 + 0];
    dst[9] = sz * m[2 * 4 + 1];
    dst[10] = sz * m[2 * 4 + 2];
    dst[11] = sz * m[2 * 4 + 3];

    if (m !== dst) {
      dst[12] = m[12];
      dst[13] = m[13];
      dst[14] = m[14];
      dst[15] = m[15];
    }

    return dst;
  }

  /**
   * creates a matrix from translation, quaternion, scale
   * @param {Number[]} translation [x, y, z] translation
   * @param {Number[]} quaternion [x, y, z, z] quaternion rotation
   * @param {Number[]} scale [x, y, z] scale
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   */
  function compose(translation, quaternion, scale, dst) {
    dst = dst || new MatType(16);

    const x = quaternion[0];
    const y = quaternion[1];
    const z = quaternion[2];
    const w = quaternion[3];

    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;

    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;

    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;

    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;

    const sx = scale[0];
    const sy = scale[1];
    const sz = scale[2];

    dst[0] = (1 - (yy + zz)) * sx;
    dst[1] = (xy + wz) * sx;
    dst[2] = (xz - wy) * sx;
    dst[3] = 0;

    dst[4] = (xy - wz) * sy;
    dst[5] = (1 - (xx + zz)) * sy;
    dst[6] = (yz + wx) * sy;
    dst[7] = 0;

    dst[8] = (xz + wy) * sz;
    dst[9] = (yz - wx) * sz;
    dst[10] = (1 - (xx + yy)) * sz;
    dst[11] = 0;

    dst[12] = translation[0];
    dst[13] = translation[1];
    dst[14] = translation[2];
    dst[15] = 1;

    return dst;
  }

  function quatFromRotationMatrix(m, dst) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const m11 = m[0];
    const m12 = m[4];
    const m13 = m[8];
    const m21 = m[1];
    const m22 = m[5];
    const m23 = m[9];
    const m31 = m[2];
    const m32 = m[6];
    const m33 = m[10];

    const trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      dst[3] = 0.25 / s;
      dst[0] = (m32 - m23) * s;
      dst[1] = (m13 - m31) * s;
      dst[2] = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      dst[3] = (m32 - m23) / s;
      dst[0] = 0.25 * s;
      dst[1] = (m12 + m21) / s;
      dst[2] = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      dst[3] = (m13 - m31) / s;
      dst[0] = (m12 + m21) / s;
      dst[1] = 0.25 * s;
      dst[2] = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      dst[3] = (m21 - m12) / s;
      dst[0] = (m13 + m31) / s;
      dst[1] = (m23 + m32) / s;
      dst[2] = 0.25 * s;
    }
  }

  function decompose(mat, translation, quaternion, scale) {
    let sx = m4.length(mat.slice(0, 3));
    const sy = m4.length(mat.slice(4, 7));
    const sz = m4.length(mat.slice(8, 11));

    // if determinate is negative, we need to invert one scale
    const det = determinate(mat);
    if (det < 0) {
      sx = -sx;
    }

    translation[0] = mat[12];
    translation[1] = mat[13];
    translation[2] = mat[14];

    // scale the rotation part
    const matrix = m4.copy(mat);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;

    matrix[0] *= invSX;
    matrix[1] *= invSX;
    matrix[2] *= invSX;

    matrix[4] *= invSY;
    matrix[5] *= invSY;
    matrix[6] *= invSY;

    matrix[8] *= invSZ;
    matrix[9] *= invSZ;
    matrix[10] *= invSZ;

    quatFromRotationMatrix(matrix, quaternion);

    scale[0] = sx;
    scale[1] = sy;
    scale[2] = sz;
  }

  function determinate(m) {
    var m00 = m[0 * 4 + 0];
    var m01 = m[0 * 4 + 1];
    var m02 = m[0 * 4 + 2];
    var m03 = m[0 * 4 + 3];
    var m10 = m[1 * 4 + 0];
    var m11 = m[1 * 4 + 1];
    var m12 = m[1 * 4 + 2];
    var m13 = m[1 * 4 + 3];
    var m20 = m[2 * 4 + 0];
    var m21 = m[2 * 4 + 1];
    var m22 = m[2 * 4 + 2];
    var m23 = m[2 * 4 + 3];
    var m30 = m[3 * 4 + 0];
    var m31 = m[3 * 4 + 1];
    var m32 = m[3 * 4 + 2];
    var m33 = m[3 * 4 + 3];
    var tmp_0 = m22 * m33;
    var tmp_1 = m32 * m23;
    var tmp_2 = m12 * m33;
    var tmp_3 = m32 * m13;
    var tmp_4 = m12 * m23;
    var tmp_5 = m22 * m13;
    var tmp_6 = m02 * m33;
    var tmp_7 = m32 * m03;
    var tmp_8 = m02 * m23;
    var tmp_9 = m22 * m03;
    var tmp_10 = m02 * m13;
    var tmp_11 = m12 * m03;

    var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
      (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
    var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
      (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
    var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
      (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
    var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
      (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

    return 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  }

  /**
   * Computes the inverse of a matrix.
   * @param {Matrix4} m matrix to compute inverse of
   * @param {Matrix4} [dst] optional matrix to store result
   * @return {Matrix4} dst or a new matrix if none provided
   * @memberOf module:webgl-3d-math
   */
  function inverse(m, dst) {
    dst = dst || new MatType(16);
    var m00 = m[0 * 4 + 0];
    var m01 = m[0 * 4 + 1];
    var m02 = m[0 * 4 + 2];
    var m03 = m[0 * 4 + 3];
    var m10 = m[1 * 4 + 0];
    var m11 = m[1 * 4 + 1];
    var m12 = m[1 * 4 + 2];
    var m13 = m[1 * 4 + 3];
    var m20 = m[2 * 4 + 0];
    var m21 = m[2 * 4 + 1];
    var m22 = m[2 * 4 + 2];
    var m23 = m[2 * 4 + 3];
    var m30 = m[3 * 4 + 0];
    var m31 = m[3 * 4 + 1];
    var m32 = m[3 * 4 + 2];
    var m33 = m[3 * 4 + 3];
    var tmp_0 = m22 * m33;
    var tmp_1 = m32 * m23;
    var tmp_2 = m12 * m33;
    var tmp_3 = m32 * m13;
    var tmp_4 = m12 * m23;
    var tmp_5 = m22 * m13;
    var tmp_6 = m02 * m33;
    var tmp_7 = m32 * m03;
    var tmp_8 = m02 * m23;
    var tmp_9 = m22 * m03;
    var tmp_10 = m02 * m13;
    var tmp_11 = m12 * m03;
    var tmp_12 = m20 * m31;
    var tmp_13 = m30 * m21;
    var tmp_14 = m10 * m31;
    var tmp_15 = m30 * m11;
    var tmp_16 = m10 * m21;
    var tmp_17 = m20 * m11;
    var tmp_18 = m00 * m31;
    var tmp_19 = m30 * m01;
    var tmp_20 = m00 * m21;
    var tmp_21 = m20 * m01;
    var tmp_22 = m00 * m11;
    var tmp_23 = m10 * m01;

    var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
      (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
    var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
      (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
    var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
      (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
    var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
      (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

    var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);

    dst[0] = d * t0;
    dst[1] = d * t1;
    dst[2] = d * t2;
    dst[3] = d * t3;
    dst[4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
      (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
    dst[5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
      (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
    dst[6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
      (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
    dst[7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
      (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
    dst[8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
      (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
    dst[9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
      (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
    dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
      (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
    dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
      (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
    dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
      (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
    dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
      (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
    dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
      (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
    dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
      (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));

    return dst;
  }

  /**
   * Takes a  matrix and a vector with 4 entries, transforms that vector by
   * the matrix, and returns the result as a vector with 4 entries.
   * @param {Matrix4} m The matrix.
   * @param {Vector4} v The point in homogenous coordinates.
   * @param {Vector4} dst optional vector4 to store result
   * @return {Vector4} dst or new Vector4 if not provided
   * @memberOf module:webgl-3d-math
   */
  function transformVector(m, v, dst) {
    dst = dst || new MatType(4);
    for (var i = 0; i < 4; ++i) {
      dst[i] = 0.0;
      for (var j = 0; j < 4; ++j) {
        dst[i] += v[j] * m[j * 4 + i];
      }
    }
    return dst;
  }

  /**
   * Takes a 4-by-4 matrix and a vector with 3 entries,
   * interprets the vector as a point, transforms that point by the matrix, and
   * returns the result as a vector with 3 entries.
   * @param {Matrix4} m The matrix.
   * @param {Vector3} v The point.
   * @param {Vector4} dst optional vector4 to store result
   * @return {Vector4} dst or new Vector4 if not provided
   * @memberOf module:webgl-3d-math
   */
  function transformPoint(m, v, dst) {
    dst = dst || new MatType(3);
    var v0 = v[0];
    var v1 = v[1];
    var v2 = v[2];
    var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];

    dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
    dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
    dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;

    return dst;
  }

  /**
   * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
   * direction, transforms that direction by the matrix, and returns the result;
   * assumes the transformation of 3-dimensional space represented by the matrix
   * is parallel-preserving, i.e. any combination of rotation, scaling and
   * translation, but not a perspective distortion. Returns a vector with 3
   * entries.
   * @param {Matrix4} m The matrix.
   * @param {Vector3} v The direction.
   * @param {Vector4} dst optional vector4 to store result
   * @return {Vector4} dst or new Vector4 if not provided
   * @memberOf module:webgl-3d-math
   */
  function transformDirection(m, v, dst) {
    dst = dst || new MatType(3);

    var v0 = v[0];
    var v1 = v[1];
    var v2 = v[2];

    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];

    return dst;
  }

  /**
   * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
   * as a normal to a surface, and computes a vector which is normal upon
   * transforming that surface by the matrix. The effect of this function is the
   * same as transforming v (as a direction) by the inverse-transpose of m.  This
   * function assumes the transformation of 3-dimensional space represented by the
   * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
   * translation, but not a perspective distortion.  Returns a vector with 3
   * entries.
   * @param {Matrix4} m The matrix.
   * @param {Vector3} v The normal.
   * @param {Vector3} [dst] The direction.
   * @return {Vector3} The transformed direction.
   * @memberOf module:webgl-3d-math
   */
  function transformNormal(m, v, dst) {
    dst = dst || new MatType(3);
    var mi = inverse(m);
    var v0 = v[0];
    var v1 = v[1];
    var v2 = v[2];

    dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
    dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
    dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];

    return dst;
  }

  function copy(src, dst) {
    dst = dst || new MatType(16);

    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];

    return dst;
  }

  return {
    copy: copy,
    lookAt: lookAt,
    addVectors: addVectors,
    subtractVectors: subtractVectors,
    scaleVector: scaleVector,
    distance: distance,
    distanceSq: distanceSq,
    normalize: normalize,
    compose: compose,
    cross: cross,
    decompose: decompose,
    dot: dot,
    identity: identity,
    transpose: transpose,
    length: length,
    lengthSq: lengthSq,
    orthographic: orthographic,
    frustum: frustum,
    perspective: perspective,
    translation: translation,
    translate: translate,
    xRotation: xRotation,
    yRotation: yRotation,
    zRotation: zRotation,
    xRotate: xRotate,
    yRotate: yRotate,
    zRotate: zRotate,
    axisRotation: axisRotation,
    axisRotate: axisRotate,
    scaling: scaling,
    scale: scale,
    multiply: multiply,
    inverse: inverse,
    transformVector: transformVector,
    transformPoint: transformPoint,
    transformDirection: transformDirection,
    transformNormal: transformNormal,
    setDefaultType: setDefaultType,
  };

}
let Mat4 = mat4();





		</script>


	</body>

	</html>
</body><html>

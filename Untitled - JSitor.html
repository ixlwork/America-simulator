<!doctype html><html><head></head><body><!doctype html>
<html>

<head></head>

<body>
	<!DOCTYPE html>
	<html>

	<body>
		<canvas id="gameBoard">
		</canvas>
	</body>

	</html>
	<script type="module">
		"use strict";
	import { mat4, glMatrix, vec3, vec4, mat3 } from "https://raw.githubusercontent.com/toji/gl-matrix/refs/heads/master/dist/gl-matrix.js";
	const loadingScreenVertexShader = `#version 300 es
	precision mediump float;
	in vec2 vertex;
	out vec2 f_vertex;
	void main(){
	gl_Position = vec4(vertex, 0.0, 1.0);
	f_vertex = vertex;
	}
	`
	const loadingScreenFragmentShader = `#version 300 es
	precision mediump float;
	in vec2 f_vertex;
	uniform float percentage;
	uniform vec2 viewport;
	uniform sampler2D tex;
	out vec4 outColor;
	
	void main(){
	vec2 coord = gl_FragCoord.xy / viewport.xy;
	coord = coord * 2.0 - 1.0;
	float percent_space = percentage * 1.5 - 0.75;
	
	if((coord.x>-0.75) && (coord.y>-0.75) && (coord.x<0.75) && (coord.y<-0.6)){ outColor=vec4(0.0, 1.0, 1.0, 1.0);
		if(coord.x<percent_space && coord.y<0.0 - 0.6 && coord.y> -0.75 && coord.x>-0.75){
		outColor = vec4(1.0, 0.0, 1.0, 1.0);
		}
		}else{
		vec2 texcoords = (coord + 1.0) / 2.0;
		outColor = texture(tex, vec2(texcoords.x, 0.0-texcoords.y));
		}
	
	
		}
		`
	
		const vertexShader = `#version 300 es
		precision mediump float;
		in vec3 a_Position;
	
		`;
		const fragmentShader = `
		`;
		var percentage = 0.0;
		var assets = [{
		renderer: { length: 5, offset: 2 }
		}, { attribName: ["vertex"], vertexShader: loadingScreenVertexShader, vertexSize: 2, fragmentShader:
		loadingScreenFragmentShader, vertexData: [-1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], indexData: [0, 2, 1, 0, 3,
		2], vertexNormal: false, vertexStride: 0, vertexOffset: 0, uniformNames: [`percentage`, "viewport"],
		numUniformLocations: 2 }, { data: vertexShader, type: "vertexShader" }, { data: fragmentShader, type:
		"fragmentShader" }, { data: ["a_Position"], type: "attribLocations" }, { data: [], type: "uniformLocations" }, {
		data: [] }];
		var assetList = [];
		var files = [];
		var loadingScreen = {
		attribName: ["vertex"], vertexShader: loadingScreenVertexShader, vertexSize: 2, fragmentShader:
		loadingScreenFragmentShader, vertexData: [-1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], indexData: [0, 2, 1, 0, 3,
		2],
		vertexNormal: false, vertexStride: 0, vertexOffset: 0, uniformNames: [`percentage`, "viewport"],
		numUniformLocations: 2
		};
		var vaos = [{
		attribs:[{vertexBuffer:"num in files", name:"attrib_name"}], indexBuffer:"num in files"
		}
		];
		var vaoIds = vaos;
		var shaderPrograms = [
		{vertexShader:"num in files", fragmentShader:"num in files", uniforms:[], }
		];
    var shaderProgramIds = shaderPrograms;
		var entities = [];
		async function main() {
	
		let canvas = document.getElementById("gameBoard");
		let gl = canvas.getContext("webgl2");
	
	
	
		resize(gl.canvas);
		clear(gl);
		let texture = loadTexFromImage(gl,
		"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxISEhUSEhIVFRUVFRUVDxUVFRUVFRUVFRUWFhUVFRUYHSggGBolHRUVITEhJSkrLi4uFx8zODMtNygtLisBCgoKDg0OFxAQGi0eHSUtLS0tLS0tLS0rLS0vLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK//AABEIALcBEwMBIgACEQEDEQH/xAAaAAACAwEBAAAAAAAAAAAAAAACAwAEBQEG/8QANxAAAQMCBAQDBgQHAQEAAAAAAQACEQMhBBIxQQVRYXETIoEykaHB0fAGQrHhFCNSYnKC8dKi/8QAGAEBAQEBAQAAAAAAAAAAAAAAAAECAwT/xAAjEQEBAAICAgICAwEAAAAAAAAAAQIRAyESMRNBUWEUcaEi/9oADAMBAAIRAxEAPwC6XqBcaEwBeR6HWMTAEGdCaiqGl6A1Uu5RtpoOZiUTWJgailUCGI0JchL0BlyEvSi9DKBpcuFBK5nQGohzqZkQcqShDU1jEVAjAUQ5kQwBdSw5EEBSuhQBREdARBDmUzIDlcc5KdVS31kNGmogNRIzroRTcymZAF0ICzKShlQlFHKiVmUUCW2XDUSmglMaFFdAJTGsQhy7nQMUzJOdcL1Q/MhL0jOhLkQ51RAXIAmNCDgC7KKFPDVCy5cThRRikgQ1icxiIgBA6ogaCAhfXVZzyVwNQPFWUQclNCJA5rkwOVWVA5EW8yEuSM6B9VDR5qpT66RcoazwwAncgDuTAUXRpfK6AjbTTAxVCw1GGokMoOrhKFzkp1RRTDUXM6UEwIOrq5mUQV2uXcyrNejBUU7MuSgzLoKDpcuZlMqJrFRxE1qNrERQcARtCFEEBBGClFyW+omzSwaiE1FTOICq4jHuFmtK53mwn23OLK/TSe9KlYlfFVgJcICpjj7wYIlZnPhtbw5PVAImsLiGgwSQAe5heeo8eP8ASr2A4yHvAiDMj0Wpy4ZdbS8eU702cbhHUiA64OjhoenQpEr01Wm2rTG7XjY/EH5rzeJ4diGOhuWoyRfSoBO40J7e5bzvgzjj5OBcLlK9CzgMwMHUEQea8/imuLGOh0vBBk7ifN0ESuH8mfh1+Ct7N1RBo5rz2DY43LPYDnDaQZgd+i0MjqdGmWMz3DncpJgknop/I/S/B+2q1uwuToOc6Icbhcz2N1DCDaLv3J7aBN4bXpssCHVDMuNg0To366rUpsBucvoSf1Xo47cpuuOcmPpmErhcmY2nlPTnMqqai1WDCULnJcroUVFwMRSuF6CKShLl1qDqi6uIM5rk0FVmuRioinBEHJIcmNZKBrXJzUFNiaFBF2EDnoC9A3MhdUSwCUXgOUyzmM3WscbldR1oJUxbNvgr2Ao6zsqwglzuWi8HLy3J7ePjmKjSy05Lru2CdSxLTsFQxD5dBS6rC35Lzebr4tuq2k8Q6Fh47hjC4BsRtCDEMcBMo+HsLR4j56DddZluMXFjY3D+Gcqu/h7FspPzVGgjbp6K2ODuquNR5gHboozhYnKwTeATpdZluN3Fslmq97wvFCtSD2gtaZDZtoSPRKxBP5Z9/wAkHDaHgUvDmSLnlr8EvEV7GASd17eTltxm/bzYcesumdj6ZLTJ2cJ2uInus3HUPKxmsNsR1cGmPetl1PxMgIgVCR2Kz69E5WiPNTLmOHQEEH4D3ryfb0KrqX8px0Ia10g/3Rpym/qrNOoMrQ3UiSOZAsPvkgOHJApgGajmCdgxrsxv6fBNNK1VzR7DiB9+9bxjORtLEhtrTBJtsNO3zVfiPFQ1oyyTmGYCfLJE9NJSclS7nCJ5bWhUsZUFJoJgh23Ofmu+GenDPDbVc8ndcVLAV5BEyBdv+J0B6hWS9euXc281mujM64XpLqi40qodnXQhaEZcAoqIfEhLqV+SWCgd4pUQAqIKLGpzWIGBPY1FE1ic1ACuqKbnQOeVyUJciCBVnDYcuKVhwCVuYXDgiW6hc889dT26YYb7qi7COZeFdo4UZC+ZsrGJe1zS3cBIwj/5RbG682WW73309OOOoVEUyB6rKxTstOPetWTBt0WPjqRMheXk9PRizsJ5nSb8lKj/AD9AmYSnlBJVjhXDjUOc6bLhMbdRu2QOEwZqPzO9kK9Tpgkkjyt9lXHBohjf9igxZFmtsNF3k1HP3VCs/wAS2jRorHCqc1Admme5GiY+gGgLuBJc8BugBuOy1j7TL0bxLFvBLaep9o6x6K5w+zclVwJ2tlHvNldpUmBrBTAE3e6xjmJXMbgZEkN01BAPxK7zjyl8vbj543r0GvhGnww05Sx4IzyARyD/AGT6FHxugBm8sGx7giJWG59WkTkMtNnMOh6RpPUK9w/GOe3zmS0ZRP8ATqAeas5ccutaqXjyne9mcPMuawC+WTyCVhsI1ragu9rnlzqkBtMdMzj5t9AVhcQ4o+mQGnK94yCBqDaeiuYzxH02D8rGgNF4HyV+SSSa3U+O2276cx7qbxkaZIMlzRlaB3K8HxkOz5WFzgDILtIC9rWxbKbLjMdwMxBO9oXmsXiWl/ivDqcCGMykjLygc1ZN91MrrqEfhvEF2edoEcjdbWZZHA3sd4jmggOfaey12hezCdPLl7E1qYBCU6sAq78QTotMrT8TCV4xKS1iYGoGNTAlsYntaoOBRHZdRVVhTQVTFRG16irWdc8RJCY2mg6XroaSjDAulyDV4dw+W5iYTaNQ03WKsYGpDII2UFBmv6rxck3luPXx9TVLFYveCRHNauGwYGYDe6VhWBokAEFaVPUHounFh+U5c/wyMThCDCy8ZR9o9F6XFgEysLiroaVw5sJjt04s7VLh2Ha9v6qzjMU2mMjIlZuCxOSmSNUvAA1amYiwXluWpJj7rvrvdWM5Hcq7w7DyZN1XFEvqQ3QLVpUixqYTvZnfpncUdeEOAdkGYbugeiXjX+070CPD3ptaQNJ7rWN72ZetNbwmE3MNcZkG08iFs4LBU4gAOHqfgdF53CYuTlyW/MJtHTqtLDOLTmpuP+MX+q9vDlj71t5OXG+t6WOKUCHAhkt/NzjsFWxGChviMbaJOxjstB2KDxpfcHX0VatWeRlY0jnOnqV3+LHK2xxnLcZI84cCcS/xYDWU9zqTEw3ta6JmLdsGRexMne4yz+m6vtzUqYpuiL6aXJOhXnOK44zlYDN4F7/6iAVLxSaavLu3RGFH8x2YGQTEkWHQKcWcKjfDpgH+o3t6ruC4VVeJeSxvLNI9ztPek8axbKbclNoMe0R5SOnlTKsyMvBvp03Gm07T67qw/EnRqxcNSmsDEOPtA7g8jutvJFl0471pzzgWsJuU5rUAKIFdGD2owUkFdzqKsB654ir55RtQNzqJZeOa6oKIVmkEqmAE4PUaPbARGqq7SjaOSBmcomoQwbldL+SD02DqTSB6QVVe1x3VLhD3mWiYmStQkiZC8fLJK9XHbpMG57batK26LvKLrz7sXbT3K9wjEE1Mp0IkLfFnN6Z5MbYsYiqs7FUc4K1uIZPy3VCiJKxz423TXDlqPI4um5thpK9D+HaQ8OI11TcbwsEW3RYYGi3KV48OO4ZdvVlnMsel7DYVjbhUuK4vKE3C17En0lYmOqy+XTBK1nZ4yRnHG7tpVQFwzG8nRa1eh/La9ou20KsXB0QLAWHdamAfAh35gFrDGXpM7Z2zqNRrxMw4ffqmnFuFngj+4aqcR4XfPTMHoq2G4h+Wprus23HLV6v+VZrKbna83Fu3h7YHm3HM211WlRrOMFvm5XXnKoObNRdrq06H7ha3D6pGnlJNwdLHZenh5bvVcOXjlnRuJwbqmrSL81UHC8omB84C2fFnzTGgMaBLeDzsvVbt5pNMHG0Wtgukg2F5g7W3CyqmAzTUc2ALN+q9BiaTBc32E6zt6JDKBfdwho2XDK3btjOnk6fDicz55+nbZLDlqfiHEEDLTMNNp37LJcIgdBK7cX25copRgpIciAXdxNzLoC40KOqR1PJRRxCWXuNm+9G2kTd3uT2hQIbhrX13UTlEVSYU9qClR5q22mN1FJa8Dqm+LyXfCGwRgAalADZKa2mutdyHvUceZRWlwLFsZmaTDnER2WvXdDSSO68Li+llYxHGa7qRp5pkRMeb3rjyYeTrx5aeu8gotIEyJldpkOqNDTEMl3ZeLw9Wq2gKWchsevaU/h2LfQJcwZszQ05idByKTCRLla9S6q+TPp2SBiodlBnmsJ/G6sE+Ue8qnwzHA1M1SpblpKx4W3tvymnvG4iB1SsQzOJGyy38VpkWPZauAxEtWbhb01M5O1bEssGTfdZmJpGeQ2lbwpCS7dVMXgszxJtFl5csLO3oxznpX4Xd3aFqU2CCDa9lnZ2N8pqNa8aHbpKd/HGMtRsjaoy49YumN1Ey7p/iOYYdcJeI4fTqiYRMcHtiZ5HWVKdMt0/6ty76ym4zZrudVg43h1WmZaSQLx20S6HGTnLKjYPtNjX+4fMeq9Q9sy124WdjeEMqwfzN3HS8rU4rj3hWbyS9ZH8O4gHM+He6sV8W0giNjEc0XC8ExjItyjtoEeJwTSNxyA6811vyeP05/wDG2O6sxgl5nkNb9VUxHEajwcoMRIGllqt4IyZJmdJXMYxrYa0Q4Wj91x8OT+o6+eH9vP08P+eq4zEtG681/GmpWJiBf4L0HG3ZWkAzUdZoGo9OS8/hsM4ECq1wGzpj3r1cOPjHm5MvKrYCZmA1Sar4OVvmP6dym0cPu4yfgF6XB1mZ2lhz3PZWqNIN0RMauudCgIocyXrqiDUV2VF3KoiE06hR/wARs256KlTaXe0f9R8yrQqNbYI0c1p/MY6D6os4GgVYPJXTUAUFjOUDnkpTCXJ7S1vU8vqgrvokobN0uU45n/dlHNay+pWa1K5TYSJcjfiABAuqVSuXfIJlFk9efIeqzpvau9hNypRwMmQI6n5BaHhAXdf9Aq2Ixk2agsENZ1Ku8Nx7ptMc1k0KOYy70C06NO3JZ21p6fDYlpYQDdZWM8R8imTLQJ7lY+Ix2SzNUrhvHatN1wHEn1PeFy5eL5P03x5+G25wrhWSalfzcpGiLivEMoDKVMZ3WbYW6lVanF/GID3hkG4Nk/BMZ/FZy4OaW+SLiTsuFwyx1jOo6zKXulUcBWbBNU53axAHbTRegwtEtb5qpcZkyB7hGymJAud9vckYSqHRzGvdax3jlqpb5TbtfEZA5xeH5dRF/wBVawQLgHExvpJI6lZ+Kw4JhsS6A6fj6rQxb/DpiPy5fcDddcbe7fpyyk6k+wcRxTmmRHW3JU8ZxE1GNyEkktBaSGm5ix2PdWMRTzep+Cz6PAy+o/z5Gtc0gxmzEeYfJXHzt/SXxkbNPC5Gk1PM6NATA/defxT2ucQQZ7nRbPEa5c2JMg32n3Lz3EaeU5gYnUSuXLlfLWLpx49brzmLqCjX8t29STF+vVbONrsexojW+um+qxfxEGhrXN9qYP8AjqJ9RCo4Tidw0GR+g2Xq45bJXnzs3WqymAeSt0wk0WjurAYTquzi453JCGJoaoAihDV2ESkoJCi7KiDGFW0NED71RB4Cqzz05fVMBn7sqH+MTYJzRzSGdFap0eZUUQeTYffqmsoAapZxAFmj1Q+Z2pt8EDquIAEN/b91ULCVZbSTG01FU2UP3VtgDRC7UcAFXDHPKy1sNVxeYHryTcPhANL9fortHCBoukYvGBtm3KzVgn5WCSfqqdXGOqeVgskfw7nnM8+krRogNHlHqdFNNbV6eB3ce6F720z5R9fVPrYkN3krLrkuMlTQHFHMQ5Cys5rpaSDzCdTbZFSaA5aRq0+N1Gtg+b/KZ6XR8P8AxA3MCaZB3gghZ1Viqs1WbjjbuxZbJp7B3HqIIJY+dbAb67pdb8V0XgksdYERGvJebYHEhW/4YDQT30CtkTts4H8SMzAZHBpI8zoESeUzC9BhsbQGYeK3zGdRY7ADkvDUaRdf/wCtvTmtHDFozbnmU9I2sfiGMJJe2DzIheS43x2nMNBeR/SJ9J0C7xAyfr8gsTE07rGPHjvdayzutRiYttWsTnMNJMNB2mwJVvA4KCFY8FX8JSuF6XFrUGgBNKW0qSiHMchJXJUAJUEiUQZAkkAbzogqVA2wueQ/U8ggDCbuudhs3t16oGeNyYSNjIHwNwopK6gwadDmmMb/AMQPrRogaXnmtC22pGg9UbQXffySaOGJuVp0mABQLp0OasNpom/9UqVg3S5UVC0DVIqVSdPeuGSb+gVqjQAu5AjD4MuufvsrbqjKdvv1SquLJswffyS2Ybd1zy2/dSrAVqz3+zYc/ol0sPl6lXywDX9vVU8Xidmx32/dRpKrwB5o6BVamJJsLDmkm990QYmjYWtXS1NDUDnKaXbgCFz0JJR0qc6D1OilUxkn7/RNYAPv7hEKJ7cyjp0AdL9Tp6Dfuoqv4hJ8snt9VoUsPI89/wC3b15/eq41oH3dR9aPoiLNTTkFXaTtYfEoA6fa9AmVHBok+gRCcQIusyq2SrdR5dc+5V6rfRWFUKjVpYOnZUrStnAUxynv9F0c6KF1rSdArppDV0dkFau1ov6AanoAgUKca/skGoXezp/V/wCRv307onS67rD+n/0d+2iLVEAxgGnqdyeZ5o2t5rphQFASi5K4gw2NAT2KKKh/iABD45KiiA21CLI6TZPzXVEVYztYJ3QgF93WHIKKKB9KmBpYKVcQ1vOVFEGdiKxJv7vqkuuuqIqLheoogHNKjWzpf9FFFFPp4cb3/RPJAtqToFFFmqINJPmv02/dOlRRZUmrUVR9eDbXc/T6rii1CnUq0XPolPr5jKiiIW+tyVapUlRRWILCUMxW7h3BogKKLTJdbFwcrRLt50E79Upusm5OpP3YdFFEQ1pXDUUUQDmXHvA1UUQCMQooorof/9k=")
	
	
		initLoadingScreen(gl);
		loadAssets();
		processAssets(gl);
	
	
	
	
		console.log(gl.getError());
		}
	
	
		function getFile(index) {
	
		return assets[index];
		}
	
	
	
		function initLoadingScreen(gl) {
	
	
	
		let shaderProgram = createProgram(gl, createVertexShader(gl, loadingScreen.vertexShader), createFragmentShader(gl,
		loadingScreen.fragmentShader));
	
	
	
		let vertexBuffer = createVertexBuffer(gl, new Float32Array(loadingScreen.vertexData), gl.STATIC_DRAW);
	
	
		let indexBuffer = createIndexBuffer(gl, loadingScreen.indexData, gl.STATIC_DRAW);
	
	
	
		let vao = createVao(gl);
	
	
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	
		gl.vertexAttribPointer(0, loadingScreen.vertexSize, gl.FLOAT, loadingScreen.vertexNormal, loadingScreen.vertexStride
		* 4, loadingScreen.vertexOffset);
	
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	
	
		gl.bindVertexArray(null);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	
	
	
		let uniformLocations = getUniformLocations(gl, shaderProgram, loadingScreen.numUniformLocations,
		loadingScreen.uniformNames);
		let attribLocations = getAttribLocations(gl, shaderProgram, 1, loadingScreen.attribName);
	
		enableAttribLocations(gl, 2, attribLocations);
	
	
	
	
	
	
		requestAnimationFrame(loadingScreenRender.bind(null, gl, shaderProgram, vao, uniformLocations, attribLocations,
		undefined, 0));
	
		}
		function loadingScreenRender(gl, shaderProgram, vao, uniformLocations, attribLocations, time, previousTime) {
		let timeStamp = performance.now() - previousTime;
	
	
	
	
	
		resize(gl.canvas);
	
		clear(gl, gl.canvas);
	
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
		gl.useProgram(shaderProgram);
		gl.uniform2fv(uniformLocations[1], new Float32Array([gl.canvas.width, gl.canvas.height]));
		gl.uniform1fv(uniformLocations[0], new Float32Array([percentage]));
	
		gl.bindVertexArray(vao);
		gl.enableVertexAttribArray(0);
		gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	
	
		if (percentage < 1.00000001) { requestAnimationFrame(loadingScreenRender.bind(null, gl, shaderProgram, vao,
			uniformLocations, attribLocations, percentage, timeStamp)); return; } } 
      function loadAssets() { 
        for (let i=0; i< assetList.length; i++) { switch (assetList[i].fileType) { case "image" : let image=new image();
			image.src=assetList[i].url; image.addEventListener("load", function () { files[i]={ data: image.toDataUrl(),
			type: assetList[i].type }; percentage +=(1 / (assetList.length + 2)) * 0.5; }); break; case "text" :
			fetch(assetList[i].url).then(response=> response.text())
			.then(textData => {
			files[i] = { data: JSON.parse(textData).data, type: assetList[i].type, usage: JSON.parse(textData).usage };
			percentage += (1 / (assetList.length + 2)) * 0.5;
			});
			break;
			}

			}
			fetch("/vaos.txt").then(response => response.text())
			.then(textData => {
			vaos = JSON.parse(textData);
			percentage += (1 / (assetList.length + 2)) * 0.5;
			});
			}
			function processAssets(gl) {
			let render = files;
			for (let i = 0; i < files.length; i++){ 
        switch (files[i].type) { case "vertexShader" :
				render[i].data=createVertexShader(gl, files[i].data); 
        break; 
        case "fragmentShader" :
				render[i].data=createFragmentShader(gl, files[i].data); 
        break; 
        case "vertexBuffer" :
				render[i].data=createVertexBuffer(gl, files[i].data, files[i].usage); 
        break;
         case "indexBuffer" :
				render[i].data=createIndexBuffer(gl, files[i].data, files[i].usage); 
        break; 
        case "texture" :
				render[i].data=loadTexFromImage(gl, files[i].data); 
        break; } 
        files=render; 
        percentage +=(1 / (files.length +
				vaos.length + shaderPrograms.length)) * 0.5; } 
        for(let i=0;i<vaos.length;i++){ 
          vaoIds[i]=createVao(gl);
  
				for(let ii=0;i<vaos[i].attribs.length;i++){ 
          gl.bindBuffer(gl.ARRAY_BUFFER, filesvaoIds[i].attribs[ii].num);
				gl.vertexAttribPointer(ii, vaos[i].attribs[ii].size, vaos[i].attribs[ii].type,
				vaos[i].attribs[ii].normalized, vaos[i].attribs[ii].stride, vaos[i].attribs[ii].offset);
         }
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, files[vaos[i].indexBuffer]); 
        gl.bindVertexArray(null); }
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); 
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        for(let i = 0;i<shaderPrograms.length;i++){
          let program = createProgram(gl, files[shaderPrograms[i].vertexShader], files[shaderPrograms[i].fragmentShader]);

        }
        
         } function
				mainRender(gl) { 
          resize(gl.canvas); 
          clear(gl); 
          gl.useProgram()
          requestAnimationFrame(mainrender.bind(gl)); } function
				uiRender(uis) { } 
        function particleRender() { } 
        function shadowMapRenderer() { } 
        function clear(gl) {
				gl.clearColor(0.5, 1.0, 1.0, 1.0); 
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } 
        function
				resize(viewport) { 
          viewport.height=window.innerHeight; 
          viewport.width=window.innerWidth; 
          return viewport; }
				function createVertexShader(gl, sourceCode) { 
          let shader=gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(shader, sourceCode); 
        gl.compileShader(shader); 
        return shader; 
        } 
        function createFragmentShader(gl, sourceCode) { 
          let shader=gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(shader, sourceCode); gl.compileShader(shader); 
        return shader; } function createProgram(gl,
				vs, fs) { let program=gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs);
				gl.linkProgram(program); gl.validateProgram(program); return program; } function createVertexBuffer(gl,
				data, usage) { let buffer=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), usage); gl.bindBuffer(gl.ARRAY_BUFFER, null); return
				buffer; } function createIndexBuffer(gl, data, usage) { let buffer=gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new
				Uint16Array(data), usage); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); return buffer; } function
				loadTexFromImage(gl, url) { let tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255,
				255])); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D,
				gl.TEXTURE_WRAP_T, gl.REPEAT); let image=new Image(); var textureInfo={ width: 1,  height: 1, texture: tex, }; image.addEventListener("load", function () {
				textureInfo.width=image.width; textureInfo.height=image.height; gl.bindTexture(gl.TEXTURE_2D,
				textureInfo.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
				gl.generateMipmap(gl.TEXTURE_2D); }); image.src=url; return textureInfo; } function createVao(gl) { let
				vao=gl.createVertexArray(); gl.bindVertexArray(vao); return vao; } function getUniformLocations(gl,
				shaderProgram, numLocations, names) { let uniformLocation=[]; for (let i=0; i < numLocations; i++) {
				uniformLocation[i]=gl.getUniformLocation(shaderProgram, names[i]); } return uniformLocation; } function
				getAttribLocations(gl, shaderProgram, numLocations, names) { let attribLocations=[]; for (let ii=0; ii <
				numLocations; ii++) { attribLocations[ii]=gl.getAttribLocation(shaderProgram, names[ii]); } return
				attribLocations; } function enableAttribLocations(gl, numlocations, locations) { for (let i=0; i <
				numlocations; i++) { gl.enableVertexAttribArray(locations[i]); } } try { main(); } catch (e) {
				console.error(e); } 
        class Entitiy{ 
          constructor(model){ 
this.position = vec3.create();
this.rotation = vec3.create();
this.scale;
this.model = model;
          } 
          set position(data){
vec3.set(position, data[0], data[1], data[2]);
          }
          set rotation(data){
vec3.set(rotation, data[0], data[1], data[2]);
          }
          set scale(data){
            scale = data;
          }
          get position(){
            return position;
          }
          get rotation(){
            return rotation;
          }
          get scale(){
            return scale;
          }
          changePosition(data){
vec3.set(position, position[0] + data[0], position[1] + data[1], position[2] + data[2] )
          }
          changeRotation(data){
vec3.set(rotation, rotation[0] + data[0], rotation[1] + data[1], rotation[2] + data[2] )
          }
          changeScale(data){
            scale += data;
          }
          }
       class Model{
         constructor(){

         }
       }

    </script>
</body>
<html>

</body>
<html><script type="text/javascript">
"use strict";

const loadingScreenVertexShader = `#version 300 es
precision mediump float;
in vec2 vertex;
out vec2 f_vertex;
void main(){
  gl_Position = vec4(vertex, 0.0, 1.0);
  f_vertex = vertex;
}
`
const loadingScreenFragmentShader = `#version 300 es
precision mediump float;
in vec2 f_vertex;
uniform float percentage;
uniform vec2 viewport;
uniform sampler2D tex;
out vec4 outColor;

void main(){
  vec2 coord = gl_FragCoord.xy / viewport.xy;
  coord = coord * 2.0 - 1.0;
  float percent_space = percentage * 1.5 - 0.75;
 
if((coord.x>-0.75) && (coord.y>-0.75) && (coord.x<0.75) && (coord.y<-0.6)){
outColor = vec4(0.0, 1.0, 1.0, 1.0);
 if(coord.x<percent_space && coord.y<0.0 - 0.6 && coord.y> -0.75 && coord.x>-0.75){
outColor = vec4(1.0, 0.0, 1.0, 1.0);
}
}else{
  vec2 texcoords = (coord + 1.0) / 2.0;
  outColor = texture(tex, vec2(texcoords.x, 0.0-texcoords.y));
}


}
`

const vertexShader = `#version 300 es
precision mediump float;
in vec3 a_Position;

`;
const fragmentShader = `
`;
var percentage = 0.0;
var assets = [{
  renderer: { length: 5, offset: 2 }
}, { attribName: ["vertex"], vertexShader: loadingScreenVertexShader, vertexSize: 2, fragmentShader: loadingScreenFragmentShader, vertexData: [-1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], indexData: [0, 2, 1, 0, 3, 2], vertexNormal: false, vertexStride: 0, vertexOffset: 0, uniformNames: [`percentage`, "viewport"], numUniformLocations: 2 }, { data: vertexShader, type: "vertexShader" }, { data: fragmentShader, type: "fragmentShader" }, { data: ["a_Position"], type: "attribLocations" }, { data: [], type: "uniformLocations" }, { data: [] }];
var assetList = [];
var files = [];
var loadingScreen = {
  attribName: ["vertex"], vertexShader: loadingScreenVertexShader, vertexSize: 2, fragmentShader:
    loadingScreenFragmentShader, vertexData: [-1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0], indexData: [0, 2, 1, 0, 3, 2],
  vertexNormal: false, vertexStride: 0, vertexOffset: 0, uniformNames: [`percentage`, "viewport"], numUniformLocations: 2
};
var vaos = [{
  attribs: [], indexBuffer: "num in files", uniforms: []
}
];
var vaoIds = vaos;
var shaderPrograms = [
  { vertexShader: "num in files", fragmentShader: "num in files" }
];
var entities = [];
async function main() {

  let canvas = document.getElementById("gameBoard");
  let gl = canvas.getContext("webgl2");



  resize(gl.canvas);
  clear(gl);
  let texture = loadTexFromImage(gl, "data:image/jpeg;base64,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")


  initLoadingScreen(gl);
  loadAssets();
  processAssets(gl);




  console.log(gl.getError());
}


function getFile(index) {

  return assets[index];
}



function initLoadingScreen(gl) {



  let shaderProgram = createProgram(gl, createVertexShader(gl, loadingScreen.vertexShader), createFragmentShader(gl, loadingScreen.fragmentShader));



  let vertexBuffer = createVertexBuffer(gl, new Float32Array(loadingScreen.vertexData), gl.STATIC_DRAW);


  let indexBuffer = createIndexBuffer(gl, loadingScreen.indexData, gl.STATIC_DRAW);



  let vao = createVao(gl);


  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

  gl.vertexAttribPointer(0, loadingScreen.vertexSize, gl.FLOAT, loadingScreen.vertexNormal, loadingScreen.vertexStride * 4, loadingScreen.vertexOffset);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);


  gl.bindVertexArray(null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);



  let uniformLocations = getUniformLocations(gl, shaderProgram, loadingScreen.numUniformLocations, loadingScreen.uniformNames);
  let attribLocations = getAttribLocations(gl, shaderProgram, 1, loadingScreen.attribName);

  enableAttribLocations(gl, 2, attribLocations);






  requestAnimationFrame(loadingScreenRender.bind(null, gl, shaderProgram, vao, uniformLocations, attribLocations, undefined, 0));

}
function loadingScreenRender(gl, shaderProgram, vao, uniformLocations, attribLocations, time, previousTime) {
  let timeStamp = performance.now() - previousTime;





  resize(gl.canvas);

  clear(gl, gl.canvas);

  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.useProgram(shaderProgram);
  gl.uniform2fv(uniformLocations[1], new Float32Array([gl.canvas.width, gl.canvas.height]));
  gl.uniform1fv(uniformLocations[0], new Float32Array([percentage]));

  gl.bindVertexArray(vao);
  gl.enableVertexAttribArray(0);
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);


  if (percentage < 1.00000001) {
    requestAnimationFrame(loadingScreenRender.bind(null, gl, shaderProgram, vao, uniformLocations, attribLocations, percentage, timeStamp));
    return;
  }


}
function loadAssets() {
  for (let i = 0; i < assetList.length; i++) {
    switch (assetList[i].fileType) {
      case "image":
        let image = new image();
        image.src = assetList[i].url;
        image.addEventListener("load", function () {
          files[i] = { data: image.toDataUrl(), type: assetList[i].type };
          percentage += (1 / (assetList.length + 2)) * 0.5;

        });
        break;
      case "text":
        fetch(assetList[i].url).then(response => response.text())
          .then(textData => {
            files[i] = { data: JSON.parse(textData).data, type: assetList[i].type, usage: JSON.parse(textData).usage };
            percentage += (1 / (assetList.length + 2)) * 0.5;
          });
        break;
    }
  }
  fetch(assetList[i].url).then(response => response.text())
    .then(textData => {
      vaos = JSON.parse(textData);
      percentage += (1 / (assetList.length + 2)) * 0.5;
    });
}
function processAssets(gl) {
  let render = files;
  for (let i = 0; i < files.length; i++) {
    switch (files[i].type) {
      case "vertexShader":
        render[i].data = createVertexShader(gl, files[i].data);
        break;
      case "fragmentShader":
        render[i].data = createFragmentShader(gl, files[i].data);
        break;
      case "vertexBuffer":
        render[i].data = createVertexBuffer(gl, files[i].data, files[i].usage);
        break;
      case "indexBuffer":
        render[i].data = createIndexBuffer(gl, files[i].data, files[i].usage);
        break;
      case "texture":
        render[i].data = loadTexFromImage(gl, files[i].data);
        break;

    }
    files = render;
    percentage += (1 / (files.length + vaos.length + shaderPrograms.length)) * 0.5;
  }
  for (let i = 0; i < vaos.length; i++) {
    vaoIds[i] = createVao(gl);
    for (let ii = 0; i < vaos[i].attribs.length; i++) {
      gl.bindBuffer(gl.ARRAY_BUFFER, files[vaos[i].attribs[ii].num]);
      gl.vertexAttribPointer(ii, vaos[i].attribs[ii].size, vaos[i].attribs[ii].type, vaos[i].attribs[ii].normalized, vaos[i].attribs[ii].stride, vaos[i].attribs[ii].offset);
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, files[vaos[i].indexBuffer]);
    gl.bindVertexArray(null);

  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
}
function mainRender(gl) {

  resize(gl.canvas);
  clear(gl);

  requestAnimationFrame(mainrender.bind(gl));
}
function uiRender(uis) {

}
function particleRender() {

}
function shadowMapRenderer() {

}
function clear(gl) {
  gl.clearColor(0.5, 1.0, 1.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}
function resize(viewport) {
  viewport.height = window.innerHeight;
  viewport.width = window.innerWidth;
  return viewport;
}


function createVertexShader(gl, sourceCode) {

  let shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(shader, sourceCode);
  gl.compileShader(shader);
  return shader;
}
function createFragmentShader(gl, sourceCode) {
  let shader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(shader, sourceCode);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl, vs, fs) {
  let program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.validateProgram(program);
  return program;

}
function createVertexBuffer(gl, data, usage) {
  let buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), usage);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return buffer;
}
function createIndexBuffer(gl, data, usage) {
  let buffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), usage);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  return buffer;
}
function loadTexFromImage(gl, url) {
  let tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  let image = new Image();
  var textureInfo = {
    width: 1,   // we don't know the size until it loads
    height: 1,
    texture: tex,
  };
  image.addEventListener("load", function () {
    textureInfo.width = image.width;
    textureInfo.height = image.height;

    gl.bindTexture(gl.TEXTURE_2D, textureInfo.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
  });
  image.src = url;
  return textureInfo;
}
function createVao(gl) {
  let vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  return vao;
}
function getUniformLocations(gl, shaderProgram, numLocations, names) {
  let uniformLocation = [];
  for (let i = 0; i < numLocations; i++) {
    uniformLocation[i] = gl.getUniformLocation(shaderProgram, names[i]);
  }
  return uniformLocation;
}
function getAttribLocations(gl, shaderProgram, numLocations, names) {
  let attribLocations = [];
  for (let ii = 0; ii < numLocations; ii++) {
    attribLocations[ii] = gl.getAttribLocation(shaderProgram, names[ii]);
  }
  return attribLocations;
}
function enableAttribLocations(gl, numlocations, locations) {
  for (let i = 0; i < numlocations; i++) {
    gl.enableVertexAttribArray(locations[i]);
  }
}
try {
  main();
} catch (e) {
  console.error(e);
}
class Entitiy {
  constructor() {

  }
}
</script></body><html>
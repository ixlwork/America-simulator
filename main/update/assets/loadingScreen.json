{"init": async function(gl){const triangleVertices = [0.0, 0.5,  -0.5, -0.5, 0.5, -0.5 ]; const triangleGeoCpuBuffer = new Float32Array(triangleVertices); const triangleGeoBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, triangleGeoBuffer); gl.bufferData(gl.ARRAY_BUFFER, triangleGeoCpuBuffer, gl.STATIC_DRAW); const vertexShaderSourceCode = await fetch("/assets/loadingScreenvs.txt").text(); const vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, vertexShaderSourceCode); gl.compileShader(vertexShader); const fragmentShaderSourceCode = await fetch("/assets/loadingScreenfs.txt").text(); const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, fragmentShaderSourceCode); gl.compileShader(fragmentShader); const helloTriangleProgram = gl.createProgram(); gl.attachShader(helloTriangleProgram, vertexShader); gl.attachShader(helloTriangleProgram, fragmentShader); gl.linkProgram(helloTriangleProgram); const vertexPositionAttributeLocation = gl.getAttribLocation(helloTriangleProgram, 'vertexPosition'); canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; gl.clearColor(0.08, 0.08, 0.08, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.viewport(0, 0, canvas.width, canvas.height); gl.useProgram(helloTriangleProgram); gl.enableVertexAttribArray(vertexPositionAttributeLocation); gl.bindBuffer(gl.ARRAY_BUFFER, triangleGeoBuffer); gl.vertexAttribPointer( vertexPositionAttributeLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0 ); gl.drawArrays(gl.TRIANGLES, 0, 3);}, "load":async function(gl){}, "assets":[]}
